#include "parallel/omp/csr/scpa_csr_omp_kernel.h"
#include <omp.h>


/**
 * Considerations on the kernel:
 * This kernel tries to overcome the limitation of the v0 one
 * by better dividing the data between the threads: such thing
 * is accomplished by not dividing the rows among the thread,
 * which might lead to scenarios where a thread is assigned
 * a subset of the rows containing a small part of the non-zeroes
 * while another thread gets a subset which contains more, so
 * in this case the non-zeroes are divided
 * On top of that, this version optimizes the number of atomic updates
 * a thread does. A version using reduction will be explored, too.
 */

void SCPA_CSR_OMP_KERNEL(IN SCPA_MMLOADER_CSR_LOADER_DATA *matrix, IN double* x, OUT double *y) {

    CSR_LOADER_DATA *data = matrix->data ;

    #pragma omp parallel
    {
        int tid = omp_get_thread_num() ;
        int threads = omp_get_num_threads() ;

        int nzLoad = data->nzNum / threads ;
        int modulus = tid < data->nzNum % threads ? tid : data->nzNum % threads ;
        int extra = tid < data->nzNum % threads ? 1 : 0 ;

        int startIdx = nzLoad * tid + modulus ;
        int count = nzLoad + extra ;

        int rowIdx = -1;
        for (int i = 0; i < data->rows -1; i++) {
            if (startIdx < data->rowIdxs[i+1]) {
                rowIdx = i ;
                break;
            }
        }
        rowIdx = rowIdx == -1 ? data->rows -1 : rowIdx ;

        double cumulated = 0. ;
        for(int i = startIdx; i < startIdx + count; i++) {
            if (rowIdx != data->rows -1 && i >= data->rowIdxs[rowIdx+1]) {
                #pragma omp atomic update
                y[rowIdx] += cumulated ;
                cumulated = 0. ;
            }
            while (rowIdx != data->rows -1 && i >= data->rowIdxs[rowIdx+1]) rowIdx++ ;
            int colIdx = data->colIdxs[i] ;
            cumulated += data->nzs[i] * x[colIdx] ;
        }
        if (rowIdx == data->rows -1) {
            #pragma omp atomic update
            y[rowIdx] += cumulated ;
        }
    }

    return ;
}