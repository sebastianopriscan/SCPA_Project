#include "parallel/omp/csr/scpa_csr_omp_kernel.h"
#include <omp.h>


/**
 * Considerations on the kernel:
 * This kernel represents a straight parallelization of the serial code,
 * might be limited by the fact that such code creates a nested loop to bind
 * the correct row index to the column indexes/values. This loop is non-rectangular,
 * so collapsing the first loop is not possible.
 * This version tries avoiding using atomic updates at each nz by cumulating the result
 * and flushing only when the calculations for the row are over
 * Another version in which reductions are used will follow
 */

void SCPA_CSR_OMP_KERNEL(IN SCPA_MMLOADER_CSR_LOADER_DATA *matrix, IN double* x, OUT double *y) {

    CSR_LOADER_DATA *data = matrix->data ;

    #pragma omp parallel
    {
        #pragma omp for schedule(guided, 4)
        for (int i = 0 ; i < data->rows -1 ; i++) {
            int start = data->rowIdxs[i] ;
            int end = data->rowIdxs[i+1] ;
            double cumulated = 0. ;
            for (int j = start ; j < end ; j++) {
                int colIdx = data->colIdxs[j] ;
                cumulated += data->nzs[j] * x[colIdx] ;
            }
            #pragma omp atomic update
            y[i] += cumulated ;
        }
        #pragma omp for
        for (int j = data->rowIdxs[data->rows-1] ; j < data->nzNum ; j++) {
            int colIdx = data->colIdxs[j] ;
            //Nothing to do for the last for except running it with a single thread
            #pragma omp atomic update
            y[data->rows -1] += data->nzs[j] * x[colIdx] ;
        }
    }

    return ;
}